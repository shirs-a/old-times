---
title: 线程
date: 2021-08-28 08:27:10
permalink: /pages/8309a5b876fc9014
categories: 
  - 后端
  - 线程
tags: 
  - null
author: 
  name: shirongsheng
  link: https://github.com/shirongsheng
---

## 概述       

提起线程，难免要被人问一嘴线程和进程的区别。      

其实，所谓进程，可以理解为一个运行中的程序，每一个程序都是一个进程。      

线程，是进程内部的划分，不同的功能可以是多个线程构成的。        

关于线程，我们需要了解很多方面，包括但不限于线程的创建方式、
线程池的使用、线程安全等等一系列操作。    

## 线程的常用操作

### 获取当前线程的名字   

```
Thread.currentThread()
``` 

## 线程的创建方式

### 继承Thread类       

线程实现方式的第一种就是继承Thread类，并重写run方法，可以看到，
run方法是没有返回值的。   

```
public class NewThread_v1 extends Thread {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "启动了");
    }
}
```

测试类 

```
public class NewThreadTest {
    public static void main(String[] args) {
        NewThread_v1 newThread_v1 = new NewThread_v1();
        NewThread_v1 newThread_v2 = new NewThread_v1();
        newThread_v1.start();
        newThread_v2.start();
    }
}
```

输出

```
Thread-0启动了
Thread-1启动了
```

可以看到，我们创建了两个NewThread_v1实例，通过Thread.currentThread().getName()
获取当前线程的名字并打印输出，构造了两个不同的线程。

### 实现Runnable接口

实现线程的第二种方式就是实现Runnable接口，可以看到，实现Runnable
接口，也是需要实现接口的run方法，该run方法与继承thread类需要重写
的方法基本一致。

```
public class NewThread_v2 implements Runnable {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "启动了");
    }
}
```

测试类

```
public class NewThreadTest {
    public static void main(String[] args) {
        //实现runable接口
        NewThread_v2 newThread_v2 = new NewThread_v2();
        new Thread(newThread_v2).start();
        new Thread(newThread_v2).start();
    }
}
```

输出

```
Thread-0启动了
Thread-1启动了
```

继承thread类的子类，本身就具备了thread的类型，可以调用父类的start
方法，而实现了runnable接口的类本身并不是一个“线程类”，需要创建一个
thread实例，并将本身作为参数传给thread，从而调用start方法。

<img src="/old-times/png/thread/1.jpg">


### 实现Callable接口

实现线程第三种方式就是实现Callable接口，与前两种方式最大的不同
就是实现callable接口的线程可以有返回值，先看实现方式。

```
import java.util.concurrent.Callable;

public class NewThread_v3 implements Callable {
    @Override
    public Object call() throws Exception {
        String result = Thread.currentThread().getName() + "启动了";
        System.out.println(result);
        return result;
    }
}
```

测试类

```
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class NewThreadTest {
    public static void main(String[] args) {
        //实现Callable接口
        NewThread_v3 newThread_v3 = new NewThread_v3();
        FutureTask futureTask = new FutureTask<>(newThread_v3);
        FutureTask futureTask2 = new FutureTask<>(newThread_v3);
        new Thread(futureTask).start();
        new Thread(futureTask2).start();
        try {
            System.out.println("获取返回值：" + futureTask.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}
```

输出

```
Thread-0启动了
Thread-1启动了
获取返回值：Thread-0启动了
```

实现Callable接口的方式可以总结为如下流程        

1、创建一个实现Callable的实现类。       

2、实现call()方法，将此线程需要执行的操作声明在call()中。     

3、创建Callable接口实现类的对象。       

4、将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象。        

5、将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()方法。    

如此，便完成了线程的创建。       

上面可以看到，Thread类的参数为一个Runnable接口，而FutureTask也可以
作为Thread的参数，毫无疑问的是FutureTask肯定也实现了Runnable接口。       

首先创建FutureTask类时，该构造方法会接收一个Callable类型的参数

<img src="/old-times/png/thread/2.jpg">

而FutureTask类实现了RunnableFuture接口。        

<img src="/old-times/png/thread/3.jpg">

RunnableFuture接口中只有一个run方法，同时该接口实现了Runnable, Future
两个接口。

<img src="/old-times/png/thread/4.jpg">

这也解释了为什么创建Thread类时，可以接收一个FutureTask类型的参数。

#### 总结

与使用Runnable相比，Callable功能更强大：        

1、相比于run()方法，call()方法可以有返回值     

2、call()方法可以抛出异常，被外面的操作捕获，获取异常的信息       

3、Callable支持泛型的返回值      

4、需要借助FutureTask类，比如获取返回结果      

Future接口：

1、可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。       

2、FutureTask是Future接口的唯一的实现类。       

3、FutureTask同时实现了Runnable、Future接口，它既可以作为Runnable被线程执行，
也可以作为Future得到Callable的返回值。      

### FutureTask使用

#### 获取返回值      

通过futureTask.get()获取call方法的返回值。     

#### 待补充...

## run()方法和start()方法有什么不同

run()方法和start()方法有什么不同,又是一个老生常谈的问题，且看下面示例。      

```
public class RunStartTest {
    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("新建线程:" + Thread.currentThread().getName() + "，启动了");
            }
        });
        thread.run();
        System.out.println("主线程:" + Thread.currentThread().getName() + "，启动了");
    }
}
```

输出

```
新建线程:main，启动了
主线程:main，启动了
```

我们都知道，正常情况下，在一个方法中，程序都是顺序执行的,上面的示例代码
新建了一个线程，但是并没有调用线程的start方法，而是调用了run方法，
输出中也使用了Thread.currentThread().getName()方法来观察当前是哪个
线程。     

从输出中可以看到，两者都在主线程main中，我们新增一个线程的目的好像并
没有达到，答案已经呼之欲出了，如果只是调用run方法，那么只是单纯
调用了一个方法，无法起到新增线程的目的。        

那么我们把方法改为start();再来看看输出情况。

```
主线程:main，启动了
新建线程:Thread-0，启动了

```
可以看到，主线程的流程并没有因为新线程的启动而发生“等待”，而是
先执行了主线程的方法，另一个线程就绪了后也执行了，而且，可以看到
线程的名字也发生了改变，说明我们新增的线程是另外一个，不再是
主线程了。     


#### 总结

run方法只是单纯的调用方法，还是当前方法所处的线程内，会按照代码
顺序顺序执行，而start方法才是多线程的创建方式。  

## volatile

### 概述


```
volatile可以保证可见性，无法保证原子性。以下执行每次都小于2500。

单例中为什么要双重判空，防止创建多余的实例，假设一种状况，当singleton还未被创建的时候，
线程r1 调用了getInstance 方法，由于此时的singleton 为空，则可以进入第一层判断，
线程r1正准备继续执行，此时，线程r2抢占cpu资源，此时r2也调用了getInstance 方法，
同理线程r1并没有实例化singleton，线程r2也可以进去判断，然后继续往下执行，
进入到同步代码块，进入第二层判断，完成了singleton 的创建，并分配空间，r2线程运行
周期结束。执行任务又回到了r1,如果没有第二层判断，线程r1 也会创建一个实列(r2线程已经创建
一个实列，第二层判断为false)，这样就完全避免掉多线程环境下会创建多个实列的的问题。

singleton = new Singleton()  可以理解为三个阶段：1 为singleton 分配空间 2 初始化singleton 
3 将创建的singleton实列指向分配的内存空间。

 因为JVM具有指令重排的特性，执行顺序有可能变成 1-3-2。 指令重排在单线程下不会出现问题，但是在多线程
下会导致一个线程获得一个未初始化的实例。例如：线程r1执行了1和3，此时r2调用 getInstance() 后发现
 singleton 不为空，因此返回 singleton， 但是此时的 singleton 还没有被初始化。
     使用 volatile 会禁止JVM指令重排，从而保证在多线程下也能正常执行。

public class VolatileAtomicityDemo {
    public volatile static int inc = 0;

    public void increase() {
        inc++;
    }

    public static void main(String[] args) throws InterruptedException {
        ExecutorService threadPool = Executors.newFixedThreadPool(5);
        VolatileAtomicityDemo volatileAtomicityDemo = new VolatileAtomicityDemo();
        for (int i = 0; i < 5; i++) {
            threadPool.execute(() -> {
                for (int j = 0; j < 500; j++) {
                    volatileAtomicityDemo.increase();
                }
            });
        }
        // 等待1.5秒，保证上面程序执行完成
        Thread.sleep(1500);
        System.out.println(inc);
        threadPool.shutdown();
    }
}
```

计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，
势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在
主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，
而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来
要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，
会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。

也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到
CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取
数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到
主存当中。举个简单的例子，比如下面的这段代码：     

```
i = i + 1;
```
当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速
缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，
最后将高速缓存中i最新的值刷新到主存当中。  


这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有
问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程
运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过
是以线程调度的形式来分别执行的）。比如同时有2个线程执行这段代码，
假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。
但是事实会是这样吗？  

可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的
CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到
内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值
为1，然后线程2把i的值写入内存。

最终结果i的值是1，而不是2。


### 原子性 



## 线程池 

### 为什么要使用线程池？

提及线程池，这个彷佛也是一个无法避免的问题(为什么这么多无法避免的问题- -)。        

其实这个也比较好理解，可以联想数据库连接池，如果没有druid等等数据库
连接池的存在，那么我们每一次操作数据库，都要进行一个数据库连接，
这样频繁的I/O操作，会对系统造成相当程度的性能损耗，极大的降低我们
系统的性能，而数据库连接池的出现，就可以让我们初始化一个连接，只有
在我们使用的时候才会建立连接，不用的时候则是处于空闲状态，对系统
性能有极大的提升。       

线程池也是相同的原理，使用线程池可以有如下好处     

1、随着业务量的增加，我们可以会创建越来越多的线程，
如果不加限制的创建线程，那么很容易造成内存溢出，从而导致程序崩溃，
而使用线程池，可以对线程创建的数量加以限制，可以有效避免该问题。        

2、如果程序中有大量短时间任务的线程任务，由于创建和销毁线程需要
和底层操作系统交互，大量时间都耗费在创建和销毁线程上，因而比较
浪费时间，系统效率很低     
而线程池里的每一个线程任务结束后，并不会死亡，而是再次回到线程池
中成为空闲状态，等待下一个对象来使用，因而借助线程池可以提高程序
的执行效率

### 线程池概述       

在使用线程池之前，可以了解相关的概念。


#### Executors 

Executors是一个使用了工厂模式的类，通过Executors我们可以创建常用的
四种线程池，如：        

```
//eg：调用方式
ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(100);

//工厂方法
 public static ExecutorService newFixedThreadPool(int var0) {
        return new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());
  }
	
  public static ExecutorService newSingleThreadExecutor() {
        return new Executors.FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()));
  }
 
  public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue());
  }
 
  public static ScheduledExecutorService newScheduledThreadPool(int var0) {
        return new ScheduledThreadPoolExecutor(var0);
  }
```

#### 线程处理流程

如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。
如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。
如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。
如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用RejectedExecutionHandler.rejectedExecution()方法。

#### 线程配置方式

CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。
I/O 密集型任务(2N)： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。

#### 线程池参数

corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。
maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。



#### Executor

Executor和Executors很像，很容易混淆，但其实也很容易区分，Executors
就是如上述所说，我们在创建线程池时会使用到，而Executor


### 笔记

上下文切换--->从一个任务切换到另一个任务

并发通常是提高程序在单处理器上的性能。
多线程意味着更大的开销，但是如果一个顺序执行的程序在某一流程中
被阻塞了(通常是I/O)，那么程序将会等待在这里；但如果是多线程程序
其他流程仍会正常的执行。

实现并发最直接的方式是在操作系统级别使用进程，进程之间是互相隔离的，
彼此不会干涉，但java中的并发编程存在如内存/I/O这种资源共享的场景。

 
## 辅助工具

### CountDownLatch

想象如下一个场景，我们有一个系统点击商品有个详情信息，这个详情
信息有商品名称，价格等基础信息，也有买了这个商品的用户对这个商品
的评论。         

其中，评论和基础信息都在不同的节点上部署，隶属于不同的模块，我们
再返回给前端的详情数据一定是调用这些接口再进行组装的。如下所示。

```
@PostMapping("/getDetails")
public JsonObject getDetails(){
    //调用基础信息
    ...
    baseInfo = ...

    //调用评论信息
    comment = ...

    //拿到了全部信息，拼接商品详情并返回
    details.setComment();
    details.setBaseInfo();
    return details;
}
```

这种顺序执行的方式固然没错，但是当详情信息很多时，我们要分别
调用不同的模块，如果其中有一个模块阻塞了，整个流程都会陷入
超时的境地。       

此时，我们可以用多个线程分别来调用不同的模块，当所有的模块
都执行完毕后，再在主线程即详情拼接返回给前端所在的线程执行即可。         

可以使用CountDownLatch,该类的构造器接收一个参数，一般几个线程
就初始化为几，同时有两个方法，一个countdown(),分别在不同的
线程中使用，线程执行完毕后调用该方法，可以将CountDownLatch初始化
的值减一；另一个await()方法，再需要等待的线程中调用，线程会陷入
阻塞状态，直至所有的线程执行完毕，级初始化的值变为0；      

首先准备调用评论模块的一个类

```
import com.alibaba.fastjson.JSONObject;

public class Comment {
    public JSONObject getComments() {
        JSONObject comments = new JSONObject();
        comments.put("coment1", "不错不错");
        comments.put("coment2", "666,下次还买");
        comments.put("coment3", "这就推荐给朋友");
        return comments;
    }
}
```

再准备一个调用基础信息的模块      

```
import com.alibaba.fastjson.JSONObject;

public class BaseInfo {
    public JSONObject getBaseInfo() {
        JSONObject baseInfo = new JSONObject();
        baseInfo.put("名称", "AOC显示屏");
        baseInfo.put("价格", "1299");
        baseInfo.put("库存", "286");
        return baseInfo;
    }
}
```

分别创建两个线程来调用两个模块      

调用基础信息模块        

```
import com.alibaba.fastjson.JSONObject;

import java.util.concurrent.CountDownLatch;

public class GetBaseInfoRunnable implements Runnable{

    private CountDownLatch countDownLatch;

    private JSONObject details;

    public GetBaseInfoRunnable(CountDownLatch countDownLatch, JSONObject details){
        this.countDownLatch = countDownLatch;
        this.details = details;
    }

    @Override
    public void run() {
        //调用基础信息模块
        JSONObject baseInfo = new BaseInfo().getBaseInfo();
        details.put("baseInfo",baseInfo);
        countDownLatch.countDown();
        System.out.println("线程：" + Thread.currentThread().getName() + "执行完毕，CountDownLatch=" + countDownLatch);
    }
}
```

调用评论模块       

```
import com.alibaba.fastjson.JSONObject;

import java.util.concurrent.CountDownLatch;

public class GetCommentRunnable implements Runnable{

    private CountDownLatch countDownLatch;

    private JSONObject details;

    public GetCommentRunnable(CountDownLatch countDownLatch,JSONObject details){
        this.countDownLatch = countDownLatch;
        this.details = details;
    }

    @Override
    public void run() {
        //调用评论模块
        JSONObject comments = new Comment().getComments();
        details.put("comments",comments);
        countDownLatch.countDown();
        System.out.println("线程：" + Thread.currentThread().getName() + "执行完毕，CountDownLatch=" + countDownLatch);
    }
}
```

测试类   

```
import com.alibaba.fastjson.JSONObject;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CountDownLatchTest {

    static JSONObject details = new JSONObject();

    static JSONObject comments = new JSONObject();

    static JSONObject baseInfo = new JSONObject();

    static CountDownLatch countDownLatch = new CountDownLatch(2);

    public static void main(String[] args) throws Exception {
        ExecutorService executorService = Executors.newFixedThreadPool(2);
        System.out.println("线程：" + Thread.currentThread().getName() + "完成CountDownLatch初始化，CountDownLatch=" + countDownLatch);
        executorService.execute(new GetBaseInfoRunnable(countDownLatch, details));
        executorService.execute(new GetCommentRunnable(countDownLatch, details));
        //等待所有线程执行完
        countDownLatch.await();
        Thread.sleep(1000);
        System.out.println("线程：" + Thread.currentThread().getName() + "等待所有线程执行完毕了，CountDownLatch=" + countDownLatch);
        System.out.println("返回详情给前端：details=" + details);
    }
}
```

输出  

```
线程：main完成CountDownLatch初始化，CountDownLatch=java.util.concurrent.CountDownLatch@675d3402[Count = 2]
线程：pool-1-thread-1执行完毕，CountDownLatch=java.util.concurrent.CountDownLatch@675d3402[Count = 1]
线程：pool-1-thread-2执行完毕，CountDownLatch=java.util.concurrent.CountDownLatch@675d3402[Count = 0]
线程：main等待所有线程执行完毕了，CountDownLatch=java.util.concurrent.CountDownLatch@675d3402[Count = 0]
返回详情给前端：details={"baseInfo":{"名称":"AOC显示屏","价格":"1299","库存":"286"},"comments":{"coment1":"不错不错","coment2":"666,下次还买","coment3":"这就推荐给朋友"}}
```

将CountDownLatch初始化值改为3，由于我们只有两个线程来执行任务，
导致只有只有两个线程调用countdown()方法，并没有减为0；固主线程
一直再等待。此时，输出为

```
static CountDownLatch countDownLatch = new CountDownLatch(3);

//输出

线程：main完成CountDownLatch初始化，CountDownLatch=java.util.concurrent.CountDownLatch@675d3402[Count = 3]
线程：pool-1-thread-1执行完毕，CountDownLatch=java.util.concurrent.CountDownLatch@675d3402[Count = 2]
线程：pool-1-thread-2执行完毕，CountDownLatch=java.util.concurrent.CountDownLatch@675d3402[Count = 1]
```

### CyclicBarrier       

可以看出，CountDownLatch是一个线程受阻，等待除了阻塞线程以外的所有
线程执行完毕，每执行完毕一个线程，coundown数量减一，当其为0时，受阻
的线程会被唤醒。        

而CyclicBarrier不同，其是在每一个线程的任务执行完毕后执行await()方法
，这样这个线程会被阻塞，会等待其他线程执行完毕，就像是一道栅栏，每一个
到达栅栏前的人都会等待其他人，只有当所有人(线程)都到达后，一同唤醒
所有的线程。      

```
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CyclicBarrierTest {

    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(3);
        ExecutorService executorService = Executors.newFixedThreadPool(3);

        for (int i = 0; i < 3; i++) {
            executorService.execute(new Runnable() {
                @Override
                public void run() {
                    System.out.println(Thread.currentThread().getName() + "准备好了");
                    try {
                        cyclicBarrier.await();
                        Thread.sleep(2000);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + "开始出发！");
                }
            });
        }
    }
}
```

输出

```
pool-1-thread-1准备好了
pool-1-thread-2准备好了
pool-1-thread-3准备好了
pool-1-thread-3开始出发！
pool-1-thread-1开始出发！
pool-1-thread-2开始出发！
```

同理，如果将上述循环改为2此，那么就满足不了条件，所有的线程
都会被阻塞。


### Semaphore

Semaphore可以解决如下场景的问题，当我们需要读取几千个文件数据时，
我们起了20个线程来并发读取，但是读取完了之后，需要将文件数据入库，
但是此时只有十个数据库连接，我们就可以用Semaphore来处理这个场景。

```
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;

public class SemaphoreTest {

    public static void main(String[] args) {
        //三个柜台办理业务
        Semaphore semaphore = new Semaphore(3);
        //五个人需要办理业务
        ExecutorService executorService = Executors.newFixedThreadPool(5);
        for (int i = 0; i < 5; i++) {
            executorService.execute(new Runnable() {
                @Override
                public void run() {
                    try {
                        semaphore.acquire();
                        System.out.println("线程：" + Thread.currentThread().getName() + "正在办理业务");
                        Thread.sleep(5000); //办理时间 5s
                        semaphore.release();
                        System.out.println("线程：" + Thread.currentThread().getName() + "办理完了");
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
    }
}
```

输出

```
线程：pool-1-thread-1正在办理业务
线程：pool-1-thread-2正在办理业务
线程：pool-1-thread-3正在办理业务
线程：pool-1-thread-2办理完了
线程：pool-1-thread-5正在办理业务
线程：pool-1-thread-4正在办理业务
线程：pool-1-thread-1办理完了
线程：pool-1-thread-3办理完了
线程：pool-1-thread-4办理完了
线程：pool-1-thread-5办理完了

```

从输出可以看到，只能三个线程抢占到了资源，当三个线程使用完毕后，后两个
线程也获得了资源。
